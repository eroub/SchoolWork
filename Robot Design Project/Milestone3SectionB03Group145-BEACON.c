#pragma config(Sensor, in1,    IRsensor1,      sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  TEST,           sensorDigitalOut)
#pragma config(Sensor, dgtl12, StateLED,       sensorDigitalOut)
#pragma config(Motor,  port1,           LEFT,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           MECHL,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           MECHR,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          RIGHT,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
int connection;
int oops = 0;

void monitorInput()
{
	if(SensorValue(button1) && !button1_pushed)
	{
		button1_pushed = true;
	}

	if(SensorValue(button2) && !button2_pushed)
	{
		button2_pushed = true;
		oops = 1;
	}
}
// ^ ABOVE LINES FROM LAB 1 CODE

typedef enum T_State {
	STARTUPnDETECT = 0,
	DRIVEnCONNECT
};


void ChangeB(int x) {
	motor(LEFT) = x;
	motor(RIGHT) = x;
} // Changes the values of both motors

const int light_threshold = 1080;

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
bool monitorLight()
{
	// Static variables are a special class of variables that maintain
	// their values between subsequent calls to a function.  The intialization
	// values are only stored in the variables when the function is first called.
	// After that, the values that were in the variable at the end of the last time
	// the function is called will be stored in the variable when the function
	// execution is started.
	static int minLevelIR1 = 4096;	// Minimum light level seen by IR sensor 1
	static int maxLevelIR1 = 0;			// Maximum light level seen by IR sensor 1
	static int diffLevelIR1 = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	int lightLevel1 = SensorValue[IRsensor1];
	bool returnValue;

	// Check if 100 msecs have elapsed.
	if ( time1[T1] > 100 )  {

		// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR1 = maxLevelIR1 - minLevelIR1;

		// Reset calculation for next 100 msecs.
		maxLevelIR1 = 0;
		minLevelIR1 = 4096;
		clearTimer(T1);

		} else {

		// Check for new minimum/maximum light levels.
		if ( lightLevel1 < minLevelIR1 ) {
			minLevelIR1 = lightLevel1;
			} else if ( lightLevel1 > maxLevelIR1 ) {
			maxLevelIR1 = lightLevel1;
		}
	}

	// Check if light level difference over threshold.
	if ( diffLevelIR1 > light_threshold ) {
		returnValue = true;
		} else {
		returnValue = false;
	}

	return(returnValue);
}

void MechNFin() {
	connection = 1;
	clearTimer(T1);
	clearTimer(T2);
	while(time1[T1] < 100) {
			motor[LEFT] = -30;
			motor[RIGHT] = 28;
	}
	wait1Msec(400);
	while(time1[T2] < 1000){
			motor[MECHL] = -15;
			motor[MECHR] = -15;
		}
	clearTimer(T1);
	clearTimer(T2);
			while(time1[T1] < 2000) {
			motor[LEFT] = 30;
			motor[RIGHT] = -28;
	}
	ChangeB(0);
	motor[MECHL] = 0;
	motor[MECHR] = 0;
} // MechnFin executes the series of motor functions that work the mechanism as well as marks completion of the task

task main()
{
	T_State robot_state = STARTUPnDETECT;
	bool beaconVisible;

	while( true ) {

		// Update sensor values (must be called at least 20 times a second for proper performance).
		beaconVisible = monitorLight();
		monitorInput();
		switch(robot_state) {
		case STARTUPnDETECT:
			SensorValue[StateLED] = 0;
			SensorValue[TEST] = 0;
			connection = 0;
			if(button1_pushed || button2_pushed){
			if(beaconVisible) {
				button1_pushed = false;
				ChangeB(0);
				robot_state = DRIVEnCONNECT;
				} else {
				ChangeB(-40);
				robot_state = STARTUPnDETECT;
			}
		}
			break;
		case DRIVEnCONNECT:
			SensorValue[StateLED] = 1;
			while(beaconVisible) {
				//ChangeB(0);
				wait1Msec(600);
				while(SensorValue[sonar] >= 30){
					if(oops == 1) {
						ChangeB(20);
						wait1Msec(75);
					}
					motor[LEFT] = -45;
					motor[RIGHT] = 43;
					if(SensorValue[sonar] <= 30){
						SensorValue[TEST] = 1;
						ChangeB(0);
						wait1Msec(800);
						if(connection == 0) MechNFin();
					}
					if(connection == 1) break;
				}
			}
			while(!beaconVisible){
				robot_state = STARTUPnDETECT;
			}
			break;
		default:
			// This should never happen.
			robot_state = STARTUPnDETECT;

		} // switch( robot_state)

	}  // while(true)

}
