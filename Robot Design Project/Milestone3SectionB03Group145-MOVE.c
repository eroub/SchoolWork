#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  bumperR,        sensorTouch)
#pragma config(Sensor, dgtl6,  bumperL,        sensorTouch)
#pragma config(Motor,  port1,           LEFT,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port10,          RIGHT,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool bumperL_pushed;
bool bumperR_pushed;

void monitorInput()
{
	if(SensorValue(bumperL) && !bumperL_pushed)
	{
		bumperL_pushed = true;
	}

	if(SensorValue(button2) && !bumperR_pushed)
	{
		bumperR_pushed = true;
	}
}

void ChangeB(int x) {
	motor(LEFT) = x;
	motor(RIGHT) = x;
} // Changes the values of both motors

bool crash(){
	return(SensorValue[bumperL] || SensorValue[bumperR]);
} // Crash function that detects input from either switch bumper sensor

void backnturn(){
	ChangeB(0);
	wait1Msec(500);
	motor(RIGHT) = -30;
	motor(LEFT) = 32;
	wait1Msec(2000);
	ChangeB(50);
	wait1Msec(2000);
} // Robot backs up and turns around

task main()
{
	bumperL_pushed = false;
	bumperR_pushed = false;
	while(true){
		monitorInput();
		if(!bumperL_pushed && !bumperR_pushed){ // If neither bumpers registers input, continue
		while(SensorValue[sonar] > 25 || SensorValue[sonar] <= 0) {
					motor(RIGHT) = 33;
					motor(LEFT) = -35;
					if(crash()) {
						backnturn();
						} // If a bumper detects the robot hit an object it spins and moves forward again
		} // Robot moves forward until it is 25cm away from an object
		backnturn(); // Backs n Turns when robot is within 25cm of an object
	}
}
}
